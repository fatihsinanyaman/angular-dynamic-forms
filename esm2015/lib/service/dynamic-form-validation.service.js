import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject, Optional } from "@angular/core";
import { Validators, NG_VALIDATORS, NG_ASYNC_VALIDATORS } from "@angular/forms";
import { DynamicFormHook } from "../model/misc/dynamic-form-control-validation.model";
import { isObject, isString } from "../utils/core.utils";
import { DYNAMIC_VALIDATORS } from "./dynamic-form-validators";
import { DEFAULT_ERROR_STATE_MATCHER, DYNAMIC_ERROR_MESSAGES_MATCHER } from "./dynamic-form-validation-matchers";
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./dynamic-form-validators";
import * as i3 from "./dynamic-form-validation-matchers";
let DynamicFormValidationService = class DynamicFormValidationService {
    constructor(_NG_VALIDATORS, _NG_ASYNC_VALIDATORS, _DYNAMIC_VALIDATORS, _DYNAMIC_ERROR_MESSAGES_MATCHER) {
        this._NG_VALIDATORS = _NG_VALIDATORS;
        this._NG_ASYNC_VALIDATORS = _NG_ASYNC_VALIDATORS;
        this._DYNAMIC_VALIDATORS = _DYNAMIC_VALIDATORS;
        this._DYNAMIC_ERROR_MESSAGES_MATCHER = _DYNAMIC_ERROR_MESSAGES_MATCHER;
    }
    getValidatorFn(validatorName, validatorArgs = null, validatorsToken = this._NG_VALIDATORS) {
        let validatorFn;
        if (Validators.hasOwnProperty(validatorName)) { // Built-in Angular Validators
            validatorFn = Validators[validatorName];
        }
        else { // Custom Validators
            if (this._DYNAMIC_VALIDATORS && this._DYNAMIC_VALIDATORS.has(validatorName)) {
                validatorFn = this._DYNAMIC_VALIDATORS.get(validatorName);
            }
            else if (validatorsToken) {
                validatorFn = validatorsToken.find(validator => validator.name === validatorName);
            }
        }
        if (validatorFn === undefined) { // throw when no validator could be resolved
            throw new Error(`validator "${validatorName}" is not provided via NG_VALIDATORS, NG_ASYNC_VALIDATORS or DYNAMIC_FORM_VALIDATORS`);
        }
        if (validatorArgs !== null) {
            return validatorFn(validatorArgs);
        }
        return validatorFn;
    }
    getValidatorFns(validatorsConfig, validatorsToken = this._NG_VALIDATORS) {
        let validatorFns = [];
        if (isObject(validatorsConfig)) {
            validatorFns = Object.keys(validatorsConfig).map(validatorConfigKey => {
                const validatorConfigValue = validatorsConfig[validatorConfigKey];
                if (this.isValidatorDescriptor(validatorConfigValue)) {
                    const descriptor = validatorConfigValue;
                    return this.getValidatorFn(descriptor.name, descriptor.args, validatorsToken);
                }
                return this.getValidatorFn(validatorConfigKey, validatorConfigValue, validatorsToken);
            });
        }
        return validatorFns;
    }
    getValidator(validatorName, validatorArgs = null) {
        return this.getValidatorFn(validatorName, validatorArgs);
    }
    getAsyncValidator(validatorName, validatorArgs = null) {
        return this.getValidatorFn(validatorName, validatorArgs, this._NG_ASYNC_VALIDATORS);
    }
    getValidators(validatorsConfig) {
        return this.getValidatorFns(validatorsConfig);
    }
    getAsyncValidators(asyncValidatorsConfig) {
        return this.getValidatorFns(asyncValidatorsConfig, this._NG_ASYNC_VALIDATORS);
    }
    updateValidators(validatorsConfig, control, model) {
        model.validators = validatorsConfig;
        if (validatorsConfig === null) {
            control.clearValidators();
        }
        else {
            control.setValidators(this.getValidators(validatorsConfig));
        }
        control.updateValueAndValidity();
    }
    updateAsyncValidators(asyncValidatorsConfig, control, model) {
        model.asyncValidators = asyncValidatorsConfig;
        if (asyncValidatorsConfig === null) {
            control.clearAsyncValidators();
        }
        else {
            control.setAsyncValidators(this.getAsyncValidators(asyncValidatorsConfig));
        }
        control.updateValueAndValidity();
    }
    showErrorMessages(control, model, hasFocus) {
        const precondition = control.invalid && model.hasErrorMessages;
        const matcher = this._DYNAMIC_ERROR_MESSAGES_MATCHER ? this._DYNAMIC_ERROR_MESSAGES_MATCHER(control, model, hasFocus) :
            DEFAULT_ERROR_STATE_MATCHER(control, model, hasFocus);
        return precondition && matcher;
    }
    parseErrorMessageConfig(template, model, error = null) {
        return template.replace(/{{\s*(.+?)\s*}}/mg, (_match, expression) => {
            let propertySource = model;
            let propertyName = expression;
            if (expression.indexOf("validator.") >= 0 && error) {
                propertySource = error;
                propertyName = expression.replace("validator.", "");
            }
            return propertySource[propertyName] !== null && propertySource[propertyName] !== undefined ?
                propertySource[propertyName] : null;
        });
    }
    createErrorMessages(control, model) {
        const messages = [];
        if (model.hasErrorMessages) {
            const messagesConfig = model.errorMessages;
            Object.keys(control.errors || {}).forEach(validationErrorKey => {
                let messageKey = validationErrorKey;
                if (validationErrorKey === "minlength" || validationErrorKey === "maxlength") {
                    messageKey = messageKey.replace("length", "Length");
                }
                if (messagesConfig.hasOwnProperty(messageKey)) {
                    const validationError = control.getError(validationErrorKey);
                    const messageTemplate = messagesConfig[messageKey];
                    messages.push(this.parseErrorMessageConfig(messageTemplate, model, validationError));
                }
            });
        }
        return messages;
    }
    isFormHook(value) {
        return isString(value) && Object.values(DynamicFormHook).includes(value);
    }
    isValidatorDescriptor(value) {
        if (isObject(value)) {
            return value.hasOwnProperty("name") && value.hasOwnProperty("args");
        }
        return false;
    }
};
DynamicFormValidationService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [NG_VALIDATORS,] }] },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [NG_ASYNC_VALIDATORS,] }] },
    { type: Map, decorators: [{ type: Optional }, { type: Inject, args: [DYNAMIC_VALIDATORS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DYNAMIC_ERROR_MESSAGES_MATCHER,] }] }
];
DynamicFormValidationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DynamicFormValidationService_Factory() { return new DynamicFormValidationService(i0.ɵɵinject(i1.NG_VALIDATORS, 8), i0.ɵɵinject(i1.NG_ASYNC_VALIDATORS, 8), i0.ɵɵinject(i2.DYNAMIC_VALIDATORS, 8), i0.ɵɵinject(i3.DYNAMIC_ERROR_MESSAGES_MATCHER, 8)); }, token: DynamicFormValidationService, providedIn: "root" });
DynamicFormValidationService = __decorate([
    Injectable({
        providedIn: "root"
    }),
    __param(0, Optional()), __param(0, Inject(NG_VALIDATORS)),
    __param(1, Optional()), __param(1, Inject(NG_ASYNC_VALIDATORS)),
    __param(2, Optional()), __param(2, Inject(DYNAMIC_VALIDATORS)),
    __param(3, Optional()), __param(3, Inject(DYNAMIC_ERROR_MESSAGES_MATCHER)),
    __metadata("design:paramtypes", [Array, Array, Map, Function])
], DynamicFormValidationService);
export { DynamicFormValidationService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1mb3JtLXZhbGlkYXRpb24uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZy1keW5hbWljLWZvcm1zL2NvcmUvIiwic291cmNlcyI6WyJsaWIvc2VydmljZS9keW5hbWljLWZvcm0tdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUlILFVBQVUsRUFDVixhQUFhLEVBQ2IsbUJBQW1CLEVBQ3RCLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUNILGVBQWUsRUFHbEIsTUFBTSxxREFBcUQsQ0FBQztBQUM3RCxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxrQkFBa0IsRUFBZ0QsTUFBTSwyQkFBMkIsQ0FBQztBQUM3RyxPQUFPLEVBQ0gsMkJBQTJCLEVBQzNCLDhCQUE4QixFQUVqQyxNQUFNLG9DQUFvQyxDQUFDOzs7OztBQUs1QyxJQUFhLDRCQUE0QixHQUF6QyxNQUFhLDRCQUE0QjtJQUVyQyxZQUF1RCxjQUE2QixFQUN2QixvQkFBd0MsRUFDekMsbUJBQThELEVBQ2xELCtCQUE0RDtRQUg3RSxtQkFBYyxHQUFkLGNBQWMsQ0FBZTtRQUN2Qix5QkFBb0IsR0FBcEIsb0JBQW9CLENBQW9CO1FBQ3pDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBMkM7UUFDbEQsb0NBQStCLEdBQS9CLCtCQUErQixDQUE2QjtJQUNwSSxDQUFDO0lBRU8sY0FBYyxDQUFDLGFBQXFCLEVBQUUsZ0JBQXFCLElBQUksRUFDaEQsa0JBQW1DLElBQUksQ0FBQyxjQUFjO1FBRXpFLElBQUksV0FBcUQsQ0FBQztRQUUxRCxJQUFJLFVBQVUsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSw4QkFBOEI7WUFFMUUsV0FBVyxHQUFJLFVBQWtCLENBQUMsYUFBYSxDQUFDLENBQUM7U0FFcEQ7YUFBTSxFQUFFLG9CQUFvQjtZQUV6QixJQUFJLElBQUksQ0FBQyxtQkFBbUIsSUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUN6RSxXQUFXLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQzthQUU3RDtpQkFBTSxJQUFJLGVBQWUsRUFBRTtnQkFDeEIsV0FBVyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxLQUFLLGFBQWEsQ0FBQyxDQUFDO2FBQ3JGO1NBQ0o7UUFFRCxJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUUsRUFBRSw0Q0FBNEM7WUFDekUsTUFBTSxJQUFJLEtBQUssQ0FDWCxjQUFjLGFBQWEscUZBQXFGLENBQUMsQ0FBQztTQUN6SDtRQUVELElBQUksYUFBYSxLQUFLLElBQUksRUFBRTtZQUN4QixPQUFRLFdBQWdDLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDM0Q7UUFFRCxPQUFPLFdBQXdCLENBQUM7SUFDcEMsQ0FBQztJQUVPLGVBQWUsQ0FBQyxnQkFBeUMsRUFDekMsa0JBQW1DLElBQUksQ0FBQyxjQUFjO1FBRTFFLElBQUksWUFBWSxHQUFnQixFQUFFLENBQUM7UUFFbkMsSUFBSSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUU1QixZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO2dCQUVsRSxNQUFNLG9CQUFvQixHQUFJLGdCQUE0QyxDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBRS9GLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDLG9CQUFvQixDQUFDLEVBQUU7b0JBRWxELE1BQU0sVUFBVSxHQUFHLG9CQUFrRCxDQUFDO29CQUV0RSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDO2lCQUNqRjtnQkFFRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsa0JBQWtCLEVBQUUsb0JBQW9CLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDMUYsQ0FBQyxDQUFDLENBQUM7U0FDTjtRQUVELE9BQU8sWUFBWSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxZQUFZLENBQUMsYUFBcUIsRUFBRSxnQkFBcUIsSUFBSTtRQUN6RCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBZ0IsQ0FBQztJQUM1RSxDQUFDO0lBRUQsaUJBQWlCLENBQUMsYUFBcUIsRUFBRSxnQkFBcUIsSUFBSTtRQUM5RCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQXFCLENBQUM7SUFDNUcsQ0FBQztJQUVELGFBQWEsQ0FBQyxnQkFBeUM7UUFDbkQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFrQixDQUFDO0lBQ25FLENBQUM7SUFFRCxrQkFBa0IsQ0FBQyxxQkFBOEM7UUFDN0QsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLHFCQUFxQixFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBdUIsQ0FBQztJQUN4RyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsZ0JBQWdELEVBQUUsT0FBd0IsRUFDMUUsS0FBOEI7UUFFM0MsS0FBSyxDQUFDLFVBQVUsR0FBRyxnQkFBZ0IsQ0FBQztRQUVwQyxJQUFJLGdCQUFnQixLQUFLLElBQUksRUFBRTtZQUUzQixPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7U0FFN0I7YUFBTTtZQUNILE9BQU8sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7U0FDL0Q7UUFFRCxPQUFPLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRUQscUJBQXFCLENBQUMscUJBQXFELEVBQUUsT0FBd0IsRUFDL0UsS0FBOEI7UUFFaEQsS0FBSyxDQUFDLGVBQWUsR0FBRyxxQkFBcUIsQ0FBQztRQUU5QyxJQUFJLHFCQUFxQixLQUFLLElBQUksRUFBRTtZQUVoQyxPQUFPLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztTQUVsQzthQUFNO1lBQ0gsT0FBTyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7U0FDOUU7UUFFRCxPQUFPLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRUQsaUJBQWlCLENBQUMsT0FBd0IsRUFBRSxLQUE4QixFQUFFLFFBQWlCO1FBRXpGLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDO1FBQy9ELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLCtCQUErQixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuSCwyQkFBMkIsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRTFELE9BQU8sWUFBWSxJQUFJLE9BQU8sQ0FBQztJQUNuQyxDQUFDO0lBRUQsdUJBQXVCLENBQUMsUUFBZ0IsRUFBRSxLQUE4QixFQUFFLFFBQWEsSUFBSTtRQUV2RixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxNQUFjLEVBQUUsVUFBa0IsRUFBRSxFQUFFO1lBRWhGLElBQUksY0FBYyxHQUFRLEtBQUssQ0FBQztZQUNoQyxJQUFJLFlBQVksR0FBVyxVQUFVLENBQUM7WUFFdEMsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUU7Z0JBRWhELGNBQWMsR0FBRyxLQUFLLENBQUM7Z0JBQ3ZCLFlBQVksR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQzthQUN2RDtZQUVELE9BQU8sY0FBYyxDQUFDLFlBQVksQ0FBQyxLQUFLLElBQUksSUFBSSxjQUFjLENBQUMsWUFBWSxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUM7Z0JBQ3hGLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQzVDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELG1CQUFtQixDQUFDLE9BQXdCLEVBQUUsS0FBOEI7UUFFeEUsTUFBTSxRQUFRLEdBQWEsRUFBRSxDQUFDO1FBRTlCLElBQUksS0FBSyxDQUFDLGdCQUFnQixFQUFFO1lBRXhCLE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxhQUF3QyxDQUFDO1lBRXRFLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsRUFBRTtnQkFFM0QsSUFBSSxVQUFVLEdBQUcsa0JBQWtCLENBQUM7Z0JBRXBDLElBQUksa0JBQWtCLEtBQUssV0FBVyxJQUFJLGtCQUFrQixLQUFLLFdBQVcsRUFBRTtvQkFDMUUsVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2lCQUN2RDtnQkFFRCxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBRTNDLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsQ0FBQztvQkFDN0QsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBVyxDQUFDO29CQUU3RCxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxlQUFlLEVBQUUsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUM7aUJBQ3hGO1lBQ0wsQ0FBQyxDQUFDLENBQUM7U0FDTjtRQUVELE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxVQUFVLENBQUMsS0FBVTtRQUNqQixPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSyxNQUFNLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBYyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzRixDQUFDO0lBRUQscUJBQXFCLENBQUMsS0FBVTtRQUU1QixJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixPQUFPLEtBQUssQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN2RTtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7Q0FDSixDQUFBOzt3Q0FsTGdCLFFBQVEsWUFBSSxNQUFNLFNBQUMsYUFBYTt3Q0FDaEMsUUFBUSxZQUFJLE1BQU0sU0FBQyxtQkFBbUI7WUFDOEIsR0FBRyx1QkFBdkUsUUFBUSxZQUFJLE1BQU0sU0FBQyxrQkFBa0I7NENBQ3JDLFFBQVEsWUFBSSxNQUFNLFNBQUMsOEJBQThCOzs7QUFMckQsNEJBQTRCO0lBSHhDLFVBQVUsQ0FBQztRQUNSLFVBQVUsRUFBRSxNQUFNO0tBQ3JCLENBQUM7SUFHZSxXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQUUsV0FBQSxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUE7SUFDakMsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUE7SUFDdkMsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUE7SUFDdEMsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLDhCQUE4QixDQUFDLENBQUE7bURBRGtCLEdBQUc7R0FKM0UsNEJBQTRCLENBb0x4QztTQXBMWSw0QkFBNEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7XG4gICAgQWJzdHJhY3RDb250cm9sLFxuICAgIEFzeW5jVmFsaWRhdG9yRm4sXG4gICAgVmFsaWRhdG9yRm4sXG4gICAgVmFsaWRhdG9ycyxcbiAgICBOR19WQUxJREFUT1JTLFxuICAgIE5HX0FTWU5DX1ZBTElEQVRPUlNcbn0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBEeW5hbWljRm9ybUNvbnRyb2xNb2RlbCB9IGZyb20gXCIuLi9tb2RlbC9keW5hbWljLWZvcm0tY29udHJvbC5tb2RlbFwiO1xuaW1wb3J0IHtcbiAgICBEeW5hbWljRm9ybUhvb2ssXG4gICAgRHluYW1pY1ZhbGlkYXRvckRlc2NyaXB0b3IsXG4gICAgRHluYW1pY1ZhbGlkYXRvcnNDb25maWdcbn0gZnJvbSBcIi4uL21vZGVsL21pc2MvZHluYW1pYy1mb3JtLWNvbnRyb2wtdmFsaWRhdGlvbi5tb2RlbFwiO1xuaW1wb3J0IHsgaXNPYmplY3QsIGlzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2NvcmUudXRpbHNcIjtcbmltcG9ydCB7IERZTkFNSUNfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGYWN0b3J5LCBWYWxpZGF0b3JzVG9rZW4gfSBmcm9tIFwiLi9keW5hbWljLWZvcm0tdmFsaWRhdG9yc1wiO1xuaW1wb3J0IHtcbiAgICBERUZBVUxUX0VSUk9SX1NUQVRFX01BVENIRVIsXG4gICAgRFlOQU1JQ19FUlJPUl9NRVNTQUdFU19NQVRDSEVSLFxuICAgIER5bmFtaWNFcnJvck1lc3NhZ2VzTWF0Y2hlclxufSBmcm9tIFwiLi9keW5hbWljLWZvcm0tdmFsaWRhdGlvbi1tYXRjaGVyc1wiO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogXCJyb290XCJcbn0pXG5leHBvcnQgY2xhc3MgRHluYW1pY0Zvcm1WYWxpZGF0aW9uU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KE5HX1ZBTElEQVRPUlMpIHByaXZhdGUgX05HX1ZBTElEQVRPUlM6IFZhbGlkYXRvckZuW10sXG4gICAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChOR19BU1lOQ19WQUxJREFUT1JTKSBwcml2YXRlIF9OR19BU1lOQ19WQUxJREFUT1JTOiBBc3luY1ZhbGlkYXRvckZuW10sXG4gICAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChEWU5BTUlDX1ZBTElEQVRPUlMpIHByaXZhdGUgX0RZTkFNSUNfVkFMSURBVE9SUzogTWFwPHN0cmluZywgVmFsaWRhdG9yIHwgVmFsaWRhdG9yRmFjdG9yeT4sXG4gICAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChEWU5BTUlDX0VSUk9SX01FU1NBR0VTX01BVENIRVIpIHByaXZhdGUgX0RZTkFNSUNfRVJST1JfTUVTU0FHRVNfTUFUQ0hFUjogRHluYW1pY0Vycm9yTWVzc2FnZXNNYXRjaGVyKSB7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRWYWxpZGF0b3JGbih2YWxpZGF0b3JOYW1lOiBzdHJpbmcsIHZhbGlkYXRvckFyZ3M6IGFueSA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzVG9rZW46IFZhbGlkYXRvcnNUb2tlbiA9IHRoaXMuX05HX1ZBTElEQVRPUlMpOiBWYWxpZGF0b3IgfCBuZXZlciB7XG5cbiAgICAgICAgbGV0IHZhbGlkYXRvckZuOiBWYWxpZGF0b3JGYWN0b3J5IHwgVmFsaWRhdG9yIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChWYWxpZGF0b3JzLmhhc093blByb3BlcnR5KHZhbGlkYXRvck5hbWUpKSB7IC8vIEJ1aWx0LWluIEFuZ3VsYXIgVmFsaWRhdG9yc1xuXG4gICAgICAgICAgICB2YWxpZGF0b3JGbiA9IChWYWxpZGF0b3JzIGFzIGFueSlbdmFsaWRhdG9yTmFtZV07XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gQ3VzdG9tIFZhbGlkYXRvcnNcblxuICAgICAgICAgICAgaWYgKHRoaXMuX0RZTkFNSUNfVkFMSURBVE9SUyAmJiB0aGlzLl9EWU5BTUlDX1ZBTElEQVRPUlMuaGFzKHZhbGlkYXRvck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yRm4gPSB0aGlzLl9EWU5BTUlDX1ZBTElEQVRPUlMuZ2V0KHZhbGlkYXRvck5hbWUpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvcnNUb2tlbikge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvckZuID0gdmFsaWRhdG9yc1Rva2VuLmZpbmQodmFsaWRhdG9yID0+IHZhbGlkYXRvci5uYW1lID09PSB2YWxpZGF0b3JOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3JGbiA9PT0gdW5kZWZpbmVkKSB7IC8vIHRocm93IHdoZW4gbm8gdmFsaWRhdG9yIGNvdWxkIGJlIHJlc29sdmVkXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYHZhbGlkYXRvciBcIiR7dmFsaWRhdG9yTmFtZX1cIiBpcyBub3QgcHJvdmlkZWQgdmlhIE5HX1ZBTElEQVRPUlMsIE5HX0FTWU5DX1ZBTElEQVRPUlMgb3IgRFlOQU1JQ19GT1JNX1ZBTElEQVRPUlNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3JBcmdzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbGlkYXRvckZuIGFzIFZhbGlkYXRvckZhY3RvcnkpKHZhbGlkYXRvckFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvckZuIGFzIFZhbGlkYXRvcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFZhbGlkYXRvckZucyh2YWxpZGF0b3JzQ29uZmlnOiBEeW5hbWljVmFsaWRhdG9yc0NvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzVG9rZW46IFZhbGlkYXRvcnNUb2tlbiA9IHRoaXMuX05HX1ZBTElEQVRPUlMpOiBWYWxpZGF0b3JbXSB7XG5cbiAgICAgICAgbGV0IHZhbGlkYXRvckZuczogVmFsaWRhdG9yW10gPSBbXTtcblxuICAgICAgICBpZiAoaXNPYmplY3QodmFsaWRhdG9yc0NvbmZpZykpIHtcblxuICAgICAgICAgICAgdmFsaWRhdG9yRm5zID0gT2JqZWN0LmtleXModmFsaWRhdG9yc0NvbmZpZykubWFwKHZhbGlkYXRvckNvbmZpZ0tleSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0b3JDb25maWdWYWx1ZSA9ICh2YWxpZGF0b3JzQ29uZmlnIGFzIER5bmFtaWNWYWxpZGF0b3JzQ29uZmlnKVt2YWxpZGF0b3JDb25maWdLZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZGF0b3JEZXNjcmlwdG9yKHZhbGlkYXRvckNvbmZpZ1ZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB2YWxpZGF0b3JDb25maWdWYWx1ZSBhcyBEeW5hbWljVmFsaWRhdG9yRGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWxpZGF0b3JGbihkZXNjcmlwdG9yLm5hbWUsIGRlc2NyaXB0b3IuYXJncywgdmFsaWRhdG9yc1Rva2VuKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWxpZGF0b3JGbih2YWxpZGF0b3JDb25maWdLZXksIHZhbGlkYXRvckNvbmZpZ1ZhbHVlLCB2YWxpZGF0b3JzVG9rZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWRhdG9yRm5zO1xuICAgIH1cblxuICAgIGdldFZhbGlkYXRvcih2YWxpZGF0b3JOYW1lOiBzdHJpbmcsIHZhbGlkYXRvckFyZ3M6IGFueSA9IG51bGwpOiBWYWxpZGF0b3JGbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbGlkYXRvckZuKHZhbGlkYXRvck5hbWUsIHZhbGlkYXRvckFyZ3MpIGFzIFZhbGlkYXRvckZuO1xuICAgIH1cblxuICAgIGdldEFzeW5jVmFsaWRhdG9yKHZhbGlkYXRvck5hbWU6IHN0cmluZywgdmFsaWRhdG9yQXJnczogYW55ID0gbnVsbCk6IEFzeW5jVmFsaWRhdG9yRm4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWxpZGF0b3JGbih2YWxpZGF0b3JOYW1lLCB2YWxpZGF0b3JBcmdzLCB0aGlzLl9OR19BU1lOQ19WQUxJREFUT1JTKSBhcyBBc3luY1ZhbGlkYXRvckZuO1xuICAgIH1cblxuICAgIGdldFZhbGlkYXRvcnModmFsaWRhdG9yc0NvbmZpZzogRHluYW1pY1ZhbGlkYXRvcnNDb25maWcpOiBWYWxpZGF0b3JGbltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsaWRhdG9yRm5zKHZhbGlkYXRvcnNDb25maWcpIGFzIFZhbGlkYXRvckZuW107XG4gICAgfVxuXG4gICAgZ2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yc0NvbmZpZzogRHluYW1pY1ZhbGlkYXRvcnNDb25maWcpOiBBc3luY1ZhbGlkYXRvckZuW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWxpZGF0b3JGbnMoYXN5bmNWYWxpZGF0b3JzQ29uZmlnLCB0aGlzLl9OR19BU1lOQ19WQUxJREFUT1JTKSBhcyBBc3luY1ZhbGlkYXRvckZuW107XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsaWRhdG9ycyh2YWxpZGF0b3JzQ29uZmlnOiBEeW5hbWljVmFsaWRhdG9yc0NvbmZpZyB8IG51bGwsIGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCxcbiAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBEeW5hbWljRm9ybUNvbnRyb2xNb2RlbCk6IHZvaWQge1xuXG4gICAgICAgIG1vZGVsLnZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzQ29uZmlnO1xuXG4gICAgICAgIGlmICh2YWxpZGF0b3JzQ29uZmlnID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGNvbnRyb2wuY2xlYXJWYWxpZGF0b3JzKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0VmFsaWRhdG9ycyh0aGlzLmdldFZhbGlkYXRvcnModmFsaWRhdG9yc0NvbmZpZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yc0NvbmZpZzogRHluYW1pY1ZhbGlkYXRvcnNDb25maWcgfCBudWxsLCBjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBEeW5hbWljRm9ybUNvbnRyb2xNb2RlbCk6IHZvaWQge1xuXG4gICAgICAgIG1vZGVsLmFzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9yc0NvbmZpZztcblxuICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3JzQ29uZmlnID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGNvbnRyb2wuY2xlYXJBc3luY1ZhbGlkYXRvcnMoKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnModGhpcy5nZXRBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzQ29uZmlnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9XG5cbiAgICBzaG93RXJyb3JNZXNzYWdlcyhjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsIG1vZGVsOiBEeW5hbWljRm9ybUNvbnRyb2xNb2RlbCwgaGFzRm9jdXM6IGJvb2xlYW4pOiBib29sZWFuIHtcblxuICAgICAgICBjb25zdCBwcmVjb25kaXRpb24gPSBjb250cm9sLmludmFsaWQgJiYgbW9kZWwuaGFzRXJyb3JNZXNzYWdlcztcbiAgICAgICAgY29uc3QgbWF0Y2hlciA9IHRoaXMuX0RZTkFNSUNfRVJST1JfTUVTU0FHRVNfTUFUQ0hFUiA/IHRoaXMuX0RZTkFNSUNfRVJST1JfTUVTU0FHRVNfTUFUQ0hFUihjb250cm9sLCBtb2RlbCwgaGFzRm9jdXMpIDpcbiAgICAgICAgICAgIERFRkFVTFRfRVJST1JfU1RBVEVfTUFUQ0hFUihjb250cm9sLCBtb2RlbCwgaGFzRm9jdXMpO1xuXG4gICAgICAgIHJldHVybiBwcmVjb25kaXRpb24gJiYgbWF0Y2hlcjtcbiAgICB9XG5cbiAgICBwYXJzZUVycm9yTWVzc2FnZUNvbmZpZyh0ZW1wbGF0ZTogc3RyaW5nLCBtb2RlbDogRHluYW1pY0Zvcm1Db250cm9sTW9kZWwsIGVycm9yOiBhbnkgPSBudWxsKTogc3RyaW5nIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgve3tcXHMqKC4rPylcXHMqfX0vbWcsIChfbWF0Y2g6IHN0cmluZywgZXhwcmVzc2lvbjogc3RyaW5nKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eVNvdXJjZTogYW55ID0gbW9kZWw7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHlOYW1lOiBzdHJpbmcgPSBleHByZXNzaW9uO1xuXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5pbmRleE9mKFwidmFsaWRhdG9yLlwiKSA+PSAwICYmIGVycm9yKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVNvdXJjZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IGV4cHJlc3Npb24ucmVwbGFjZShcInZhbGlkYXRvci5cIiwgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVNvdXJjZVtwcm9wZXJ0eU5hbWVdICE9PSBudWxsICYmIHByb3BlcnR5U291cmNlW3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgcHJvcGVydHlTb3VyY2VbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNyZWF0ZUVycm9yTWVzc2FnZXMoY29udHJvbDogQWJzdHJhY3RDb250cm9sLCBtb2RlbDogRHluYW1pY0Zvcm1Db250cm9sTW9kZWwpOiBzdHJpbmdbXSB7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgaWYgKG1vZGVsLmhhc0Vycm9yTWVzc2FnZXMpIHtcblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXNDb25maWcgPSBtb2RlbC5lcnJvck1lc3NhZ2VzIGFzIER5bmFtaWNWYWxpZGF0b3JzQ29uZmlnO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb250cm9sLmVycm9ycyB8fCB7fSkuZm9yRWFjaCh2YWxpZGF0aW9uRXJyb3JLZXkgPT4ge1xuXG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VLZXkgPSB2YWxpZGF0aW9uRXJyb3JLZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yS2V5ID09PSBcIm1pbmxlbmd0aFwiIHx8IHZhbGlkYXRpb25FcnJvcktleSA9PT0gXCJtYXhsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlS2V5ID0gbWVzc2FnZUtleS5yZXBsYWNlKFwibGVuZ3RoXCIsIFwiTGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc0NvbmZpZy5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlS2V5KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IGNvbnRyb2wuZ2V0RXJyb3IodmFsaWRhdGlvbkVycm9yS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVRlbXBsYXRlID0gbWVzc2FnZXNDb25maWdbbWVzc2FnZUtleV0gYXMgc3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2godGhpcy5wYXJzZUVycm9yTWVzc2FnZUNvbmZpZyhtZXNzYWdlVGVtcGxhdGUsIG1vZGVsLCB2YWxpZGF0aW9uRXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG5cbiAgICBpc0Zvcm1Ib29rKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSAmJiAoT2JqZWN0LnZhbHVlcyhEeW5hbWljRm9ybUhvb2spIGFzIHN0cmluZ1tdKS5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaXNWYWxpZGF0b3JEZXNjcmlwdG9yKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblxuICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpICYmIHZhbHVlLmhhc093blByb3BlcnR5KFwiYXJnc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXX0=